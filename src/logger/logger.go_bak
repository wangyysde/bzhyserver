/**
* SYSADM Server
* @Author  Wayne Wang <net_use@bzhy.com>
* @Copyright Bzhy Network
* @HomePage http://www.sysadm.cn
* @Version 0.21.03
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*       @License GNU Lesser General Public License  https://www.sysadm.cn/lgpl.html
* @Modified Mar 29 2021
**/

package logger

import (
	"fmt"
	"os"
	"strings"
	"time"

	log "github.com/sirupsen/logrus"
)

/*
configLogger struct used to save parameters for logger, such as access log file error log file
*/

type ConfigLogger struct {
	//accessLoggerFile is the path of access log file ,if logger access log to a file
	accessLoggerFile string
	//errorLoggerFile is the path of error log file ,if logger error log to a file
	errorLoggerFile string

	//The file descriptor of the access log file
	accessFp *os.File
	//The file descriptor of the error log file
	errorFp *os.File

	//Logger for access log
	accessLogger *log.Logger
	//Logger for error log
	errorLogger *log.Logger
	//Logger for stdout
	stdoutLogger *log.Logger

	//set log level
	loggerLevel string
	//set log formate for output
	loggerFormat string
	//set date formate
	dateFormat string

	//If all log message log to stdout ,then allstdout should be set to True
	allstdout bool
}

var ConfigLogLevel = [7]string{"panic", "fatal", "error", "warn", "info", "debug", "trace"}

//Set global variable config and its default value
var Config = ConfigLogger{
	accessLoggerFile: "",
	errorLoggerFile:  "",

	accessFp: nil,
	errorFp:  nil,

	accessLogger: nil,
	errorLogger:  nil,
	stdoutLogger: nil,

	loggerLevel:   "Debug",
	loggerFormat: "Text",
	dateFormat:   time.RFC3339, //Ref: https://studygolang.com/static/pkgdoc/pkg/time.htm#Time.Format
	allstdout:     true,
}

/*
* initated a logger to logging log message to stdout
 */
func InitStdoutLogger() (stdoutLogger *log.Logger, err error) {
	stdoutLogger = log.New()
	stdoutLogger.Out = os.Stdout
	stdoutLogger = SetLoglevel(stdoutLogger)
	stdoutLogger = SetLogFormat(stdoutLogger)

	Config.stdoutLogger = stdoutLogger

	return stdoutLogger, nil

}

/*
* Init logger enity for access or error.
* before call this func, ConfigLogfile(logType, logFile) should be called
 */
func InitLogger(logType string) (logger *log.Logger, err error) {
	err = nil
	if strings.ToLower(logType) != "access" && strings.ToLower(logType) != "error" {
		err = fmt.Errorf("LogType must be access or error.You input is: %s", logType)
		return nil, err
	}

	if strings.ToLower(logType) == "access" {
		if Config.accessFp == nil {
			err = fmt.Errorf("May be not set access log, you should call ConfigLogfile(%s, logFile) before call InitLogger", logType)
			return nil, err
		}
		logger = log.New()
		logger.Out = Config.accessFp
		logger = SetLoglevel(logger)
		logger = SetLogFormat(logger)
		Config.accessLogger = logger
		return logger, nil
	}

	if Config.errorFp == nil {
		err = fmt.Errorf("May be not set error log, you should call ConfigLogfile(%s, logFile) before call InitLogger", logType)
		return nil, err
	}

	logger = log.New()
	logger.Out = Config.errorFp
	logger = SetLoglevel(logger)
	logger = SetLogFormat(logger)
	Config.errorLogger = logger

	return logger, nil
}

/*
* set log formate to text or json and set loggerFormat
* the fields of the struct of loggerFormat refer to :https://pkg.go.dev/github.com/sirupsen/logrus#JSONFormatter
 */
func SetLogFormat(Logger *log.Logger) (logger *log.Logger) {
	if strings.ToLower(Config.loggerFormat) == "text" {
		Logger.SetFormatter(&log.TextFormatter{
			ForceColors:               true, //Ref: https://pkg.go.dev/github.com/sirupsen/logrus#pkg-functions
			DisableColors:             false,
			ForceQuote:                true,
			DisableQuote:              false,
			EnvironmentOverrideColors: true,
			DisableTimestamp:          false,
			FullTimestamp:             true,
			TimestampFormat:           Config.dateFormat,
			DisableSorting:            true,
			DisableLevelTruncation:    true,
			PadLevelText:              true,
		})
	} else {
		Logger.SetFormatter(&log.JSONFormatter{
			TimestampFormat:  Config.dateFormat,
			DisableTimestamp: false,
		})
	}

	return Logger

}

/*
* set logger level to Config.loggerLevel
 */
func SetLoglevel(Logger *log.Logger) (logger *log.Logger) {

	switch strings.ToLower(Config.loggerLevel) {
	case "panic":
		Logger.SetLevel(log.PanicLevel)
		break
	case "fatal":
		Logger.SetLevel(log.FatalLevel)
		break
	case "error":
		Logger.SetLevel(log.ErrorLevel)
		break
	case "warn":
		Logger.SetLevel(log.WarnLevel)
		break
	case "info":
		Logger.SetLevel(log.InfoLevel)
		break
	case "debug":
		Logger.SetLevel(log.DebugLevel)
		break
	case "trace":
		Logger.SetLevel(log.TraceLevel)
		break
	}

	return Logger
}

/*
* according to logType, ConfigLogfile set logFile to Config.accessLoggerFile or Config.errorLoggerFile
* and set file descriptor to accessFp or errorFp if logFile can be opened.
* to close the openned file on time, a defer function should be called following call this function if this return successful.
 */
func ConfigLogfile(logType string, logFile string) (fp *os.File, err error) {

	err = nil
	if strings.ToLower(logType) != "access" && strings.ToLower(logType) != "error" {
		err = fmt.Errorf("LogType must be access or error.You input is: %s", logType)
		return nil, err
	}

	fp, err = os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
	if err != nil {
		err = fmt.Errorf("Open %s log file %s error: %s", logType, logFile, fmt.Sprintf("%s", err))
		return nil, err
	}

	if strings.ToLower(logType) == "access" {
		Config.accessFp = fp
		Config.accessLoggerFile = logFile
	} else {
		Config.errorFp = fp
		Config.errorLoggerFile = logFile

	}

	return fp, nil
}

/*
* set loglevel value into Config.loggerLevel
* loglevel is a string value one of panic,fatal,error,warn,info,debug,trace
 */
func SetConfigLogLevel(loglevel string) (err error) {
	err = nil
	found := false
	for i := 0; i < len(ConfigLogLevel); i++ {
		if strings.ToLower(loglevel) == ConfigLogLevel[i] {
			found = true
			Config.loggerLevel = strings.ToLower(loglevel)
			break
		}
	}

	if found {
		return nil
	}

	err = fmt.Errorf("You input logLevel %s is not available", loglevel)

	return err
}

/**
* Logging a access log message
* if the Config.allstdout ,then logging the log messages to stdout
* if Config.accessLogger is not nil ,then logging the log messages to access logfile
 */
func LoggingAccessLog(args ...interface{}) {

	var logger *log.Logger = Config.accessLogger
	var stdoutLogger *log.Logger = nil
	if Config.allstdout && Config.stdoutLogger != nil {
		stdoutLogger = Config.stdoutLogger
	}

	switch strings.ToLower(Config.loggerLevel) {
	case "panic":
		if logger != nil {
			logger.Panic(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Panic(args...)
		}
		break
	case "fatal":
		if logger != nil {
			logger.Fatal(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Fatal(args...)
		}
		break
	case "error":
		if logger != nil {
			logger.Error(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Error(args...)
		}
		break
	case "warn":
		if logger != nil {
			logger.Warn(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Warn(args...)
		}
		break
	case "info":
		if logger != nil {
			logger.Info(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Info(args...)
		}
		break
	case "debug":
		if logger != nil {
			logger.Debug(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Debug(args...)
		}
		break
	case "trace":
		if logger != nil {
			logger.Trace(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Trace(args...)
		}
		break
	}
}

/*
 * Logging a access log message
 * if the Config.allstdout ,then logging the log messages to stdout
 * if Config.accessLogger is not nil ,then logging the log messages to access logfile
 */
func LoggingAccessLogf(format string, args ...interface{}) {

	var logger *log.Logger = Config.accessLogger
	var stdoutLogger *log.Logger = nil
	if Config.allstdout && Config.stdoutLogger != nil {
		stdoutLogger = Config.stdoutLogger
	}

	switch strings.ToLower(Config.loggerLevel) {
	case "panic":
		if logger != nil {
			logger.Panicf(format, args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Panicf(format, args...)
		}
		break
	case "fatal":
		if logger != nil {
			logger.Fatalf(format, args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Fatalf(format, args...)
		}
		break
	case "error":
		if logger != nil {
			logger.Errorf(format, args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Errorf(format, args...)
		}
		break
	case "warn":
		if logger != nil {
			logger.Warnf(format, args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Warnf(format, args...)
		}
		break
	case "info":
		if logger != nil {
			logger.Infof(format, args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Infof(format, args...)
		}
		break
	case "debug":
		if logger != nil {
			logger.Debugf(format, args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Debugf(format, args...)
		}
		break
	case "trace":
		if logger != nil {
			logger.Tracef(format, args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Tracef(format, args...)
		}
		break
	}
}

/*
* Logging a access log message
* if the Config.allstdout ,then logging the log messages to stdout
* if Config.accessLogger is not nil ,then logging the log messages to access logfile
 */
func LoggingAccessLogln(args ...interface{}) {

	var logger *log.Logger = Config.accessLogger
	var stdoutLogger *log.Logger = nil

	if Config.allstdout && Config.stdoutLogger != nil {
		stdoutLogger = Config.stdoutLogger
	}

	switch strings.ToLower(Config.loggerLevel) {
	case "panic":
		if logger != nil {
			logger.Panicln(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Panicln(args...)
		}
		break
	case "fatal":
		if logger != nil {
			logger.Fatalln(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Fatalln(args...)
		}
		break
	case "error":
		if logger != nil {
			logger.Errorln(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Errorln(args...)
		}
		break
	case "warn":
		if logger != nil {
			logger.Warnln(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Warnln(args...)
		}
		break
	case "info":
		if logger != nil {
			logger.Infoln(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Infoln(args...)
		}
		break
	case "debug":
		if logger != nil {
			logger.Debugln(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Debugln(args...)
		}
		break
	case "trace":
		if logger != nil {
			logger.Traceln(args...)
		}
		if stdoutLogger != nil {
			stdoutLogger.Traceln(args...)
		}
		break
	}
}
 /*
  * Logging a access log message
  * if the Config.allstdout ,then logging the log messages to stdout
  * if Config.accessLogger is not nil ,then logging the log messages to access logfile
  */
 func LoggingAccessLogFn(fn log.LogFunction)  {
 
   var logger *log.Logger = Config.accessLogger
   var stdoutLogger *log.Logger = nil
   if Config.allstdout && Config.stdoutLogger != nil {
     stdoutLogger = Config.stdoutLogger
   }
 
   switch strings.ToLower(Config.loggerLevel) {
   case "panic":
     if logger != nil {
       logger.PanicFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.PanicFn(fn)
     }
     break
   case "fatal":
     if logger != nil {
       logger.FatalFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.FatalFn(fn)
     }
     break
   case "error":
     if logger != nil {
       logger.ErrorFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.ErrorFn(fn)
     }
     break
   case "warn":
     if logger != nil {
       logger.WarnFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.WarnFn(fn)
     }
     break
   case "info":
     if logger != nil {
       logger.InfoFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.InfoFn(fn)
     } 
     break
   case "debug":
     if logger != nil {
       logger.DebugFn(fn)
     } 
     if stdoutLogger != nil {
       stdoutLogger.DebugFn(fn)
     } 
     break
   case "trace":
     if logger != nil {
       logger.TraceFn(fn)
     } 
     if stdoutLogger != nil {
       stdoutLogger.TraceFn(fn)
     } 
     break
   }
 }                                                                                                                                                                                             LoggingAccessLog() unix | utf-8 326:  1  93% 
 /*
  * Logging a access log message
  * if the Config.allstdout ,then logging the log messages to stdout
  * if Config.accessLogger is not nil ,then logging the log messages to access logfile
  */
 func LoggingAccessLogFn(fn log.LogFunction)  {
 
   var logger *log.Logger = Config.accessLogger
   var stdoutLogger *log.Logger = nil
   if Config.allstdout && Config.stdoutLogger != nil {
     stdoutLogger = Config.stdoutLogger
   }
 
   switch strings.ToLower(Config.loggerLevel) {
   case "panic":
     if logger != nil {
       logger.PanicFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.PanicFn(fn)
     }
     break
   case "fatal":
     if logger != nil {
       logger.FatalFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.FatalFn(fn)
     }
     break
   case "error":
     if logger != nil {
       logger.ErrorFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.ErrorFn(fn)
     }
     break
   case "warn":
     if logger != nil {
       logger.WarnFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.WarnFn(fn)
     }
     break
   case "info":
     if logger != nil {
       logger.InfoFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.InfoFn(fn)
     } 
     break
   case "debug":
     if logger != nil {
       logger.DebugFn(fn)
     } 
     if stdoutLogger != nil {
       stdoutLogger.DebugFn(fn)
     } 
     break
   case "trace":
     if logger != nil {
       logger.TraceFn(fn)
     } 
     if stdoutLogger != nil {
       stdoutLogger.TraceFn(fn)
     } 
     break
   }
 }                                                                                                                                                                                             LoggingAccessLog() unix | utf-8 326:  1  93% 
 /*
  * Logging a error log message
  * if the Config.allstdout ,then logging the log messages to stdout
  * if Config.errorLogger is not nil ,then logging the log messages to access logfile
  */
 func LoggingErrorLog(args ...interface{}){
   var logger *log.Logger = Config.errorLogger
   var stdoutLogger *log.Logger = nil
   if Config.allstdout && Config.stdoutLogger != nil {
     stdoutLogger = Config.stdoutLogger
   }
 
   switch strings.ToLower(Config.loggerLevel) {
   case "panic":
     if logger != nil {
       logger.Panic(args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Panic(args...)
     }
     break
   case "fatal":
     if logger != nil {
       logger.Fatal(args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Fatal(args...)
     }
     break
   case "error":
     if logger != nil {
       logger.Error(args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Error(args...)
     }
     break
   case "warn":
     if logger != nil {
       logger.Warn(args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Warn(args...)
     }
     break
   case "info":
     if logger != nil {
       logger.Info(args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Info(args...)
     } 
     break
   case "debug":
     if logger != nil {
       logger.Debug(args...)
     } 
     if stdoutLogger != nil {
       stdoutLogger.Debug(args...)
     } 
     break
   case "trace":
     if logger != nil {
       logger.Trace(args...)
     } 
     if stdoutLogger != nil {
       stdoutLogger.Trace(args...)
     } 
     break
   }
 }
 
 /*
  * Logging a error log message
  * if the Config.allstdout ,then logging the log messages to stdout
  * if Config.errorLogger is not nil ,then logging the log messages to access logfile
  */
 func LoggingErrorLogf(format string, args ...interface{}) {
   var logger *log.Logger = Config.errorLogger
   var stdoutLogger *log.Logger = nil
   if Config.allstdout && Config.stdoutLogger != nil {
     stdoutLogger = Config.stdoutLogger
   }
 
   switch strings.ToLower(Config.loggerLevel) {
   case "panic":
     if logger != nil {
       logger.Panicf(format,args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Panicf(format,args...)
     }
     break
   case "fatal":
     if logger != nil {
       logger.Fatalf(format,args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Fatalf(format,args...)
     }
     break
   case "error":
     if logger != nil {
       logger.Errorf(format,args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Errorf(format,args...)
     }
     break
   case "warn":
     if logger != nil {
       logger.Warnf(format,args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Warnf(format,args...)
     }
     break
   case "info":
     if logger != nil {
       logger.Infof(format,args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Infof(format,args...)
     } 
     break
   case "debug":
     if logger != nil {
       logger.Debugf(format,args...)
     } 
     if stdoutLogger != nil {
       stdoutLogger.Debugf(format,args...)
     } 
     break
   case "trace":
     if logger != nil {
       logger.Tracef(format,args...)
     } 
     if stdoutLogger != nil {
       stdoutLogger.Tracef(format,args...)
     } 
     break
   }
 } 
                                                                                                                                                                                              LoggingAccessLog() unix | utf-8 326:  1  93% 
 /*
  * Logging a error log message
  * if the Config.allstdout ,then logging the log messages to stdout
  * if Config.errorLogger is not nil ,then logging the log messages to error logfile
  */
 func LoggingErrorLogln(args ...interface{}) {
   var logger *log.Logger = Config.errorLogger
   var stdoutLogger *log.Logger = nil
   if Config.allstdout && Config.stdoutLogger != nil {
     stdoutLogger = Config.stdoutLogger
   }
 
   switch strings.ToLower(Config.loggerLevel) {
   case "panic":
     if logger != nil {
       logger.Panicln(args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Panicln(args...)
     }
     break
   case "fatal":
     if logger != nil {
       logger.Fatalln(args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Fatalln(args...)
     }
     break
   case "error":
     if logger != nil {
       logger.Errorln(args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Errorln(args...)
     }
     break
   case "warn":
     if logger != nil {
       logger.Warnln(args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Warnln(args...)
     }
     break
   case "info":
     if logger != nil {
       logger.Infoln(args...)
     }
     if stdoutLogger != nil {
       stdoutLogger.Infoln(args...)
     } 
     break
   case "debug":
     if logger != nil {
       logger.Debugln(args...)
     } 
     if stdoutLogger != nil {
       stdoutLogger.Debugln(args...)
     } 
     break
   case "trace":
     if logger != nil {
       logger.Traceln(args...)
     } 
     if stdoutLogger != nil {
       stdoutLogger.Traceln(args...)
     } 
     break
   }
 }
                                                                                                                                                                                               LoggingAccessLog() unix | utf-8 326:  1  93% 
 /*
  * Logging a error log message
  * if the Config.allstdout ,then logging the log messages to stdout
  * if Config.errorLogger is not nil ,then logging the log messages to error logfile
  */
 func LoggingErrorLogFn(fn log.LogFunction) {
   var logger *log.Logger = Config.errorLogger
   var stdoutLogger *log.Logger = nil
   if Config.allstdout && Config.stdoutLogger != nil {
     stdoutLogger = Config.stdoutLogger
   }
 
   switch strings.ToLower(Config.loggerLevel) {
   case "panic":
     if logger != nil {
       logger.PanicFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.PanicFn(fn)
     }
     break
   case "fatal":
     if logger != nil {
       logger.FatalFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.FatalFn(fn)
     }
     break
   case "error":
     if logger != nil {
       logger.ErrorFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.ErrorFn(fn)
     }
     break
   case "warn":
     if logger != nil {
       logger.WarnFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.WarnFn(fn)
     }
     break
   case "info":
     if logger != nil {
       logger.InfoFn(fn)
     }
     if stdoutLogger != nil {
       stdoutLogger.InfoFn(fn)
     } 
     break
   case "debug":
     if logger != nil {
       logger.DebugFn(fn)
     } 
     if stdoutLogger != nil {
       stdoutLogger.DebugFn(fn)
     } 
     break
   case "trace":
     if logger != nil {
       logger.TraceFn(fn)
     } 
     if stdoutLogger != nil {
       stdoutLogger.TraceFn(fn)
     } 
     break
   }
 }
                                                                                                                                                                                               LoggingAccessLog() unix | utf-8 326:  1  93% 
